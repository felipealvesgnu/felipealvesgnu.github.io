<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-12-28T14:24:50-04:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Felipe’s blog - Software Development</title><subtitle>An amazing website.</subtitle><author><name>Felipe A L Pereira</name></author><entry><title type="html">IntelliJ - Application context configuration</title><link href="http://localhost:4000/intellij/java/intellij-application-context-configuration/" rel="alternate" type="text/html" title="IntelliJ - Application context configuration" /><published>2016-11-23T11:05:04-03:00</published><updated>2016-11-23T11:05:04-03:00</updated><id>http://localhost:4000/intellij/java/intellij-application-context-configuration</id><content type="html" xml:base="http://localhost:4000/intellij/java/intellij-application-context-configuration/">After spending some time trying to discover why my JSF application worked on eclipse and didn't on IntelliJ, I found a TomCat setup configuration at **Run/Debug Configurations.**

And it was like in that picture bellow:

&lt;figure&gt;
    &lt;a href=&quot;/assets/images/intelliJ/pic_01_context.png&quot;&gt;&lt;img src=&quot;/assets/images/intelliJ/pic_01_context.png&quot;&gt;&lt;/a&gt;
&lt;/figure&gt;



Without notice I was getting http status 500 error message as the pic bellow after the deployment:

&lt;figure&gt;
    &lt;a href=&quot;/assets/images/intelliJ/pic_02_context.png&quot;&gt;&lt;img src=&quot;/assets/images/intelliJ/pic_02_context.png&quot;&gt;&lt;/a&gt;
&lt;/figure&gt;


### **Solution**


After search a little I found what was missing on that configuration.

The context root of a web application determines which URLs Tomcat will delegate to your web application.

In **Application context** field, you need to put the context path for your project. Generally is recommended that you specify the same context path that you chose to the Maven project. The context path can be found in the root POM file of your project as a &lt;_context-root_&gt; tag.

&lt;figure&gt;
    &lt;a href=&quot;/assets/images/intelliJ/pic_03_context.png&quot;&gt;&lt;img src=&quot;/assets/images/intelliJ/pic_03_context.png&quot;&gt;&lt;/a&gt;
&lt;/figure&gt;



So the main point here is: Be aware of the application context, which defaults to “/” This means your application when deployed to the server would be available at “http://localhost:8080**//**” if you want it to be deployed to another path, you need to update the value in the **Application Context** field. As in my case I put the same WAR application name.



After that all the things are working and Mojarra found the root context as the image bellow:

&lt;figure&gt;
    &lt;a href=&quot;/assets/images/intelliJ/pic_04_context.png&quot;&gt;&lt;img src=&quot;/assets/images/intelliJ/pic_04_context.png&quot;&gt;&lt;/a&gt;
&lt;/figure&gt;





That's All.</content><author><name>felipealvesgnu</name></author><summary type="html">After spending some time trying to discover why my JSF application worked on eclipse and didn’t on IntelliJ, I found a TomCat setup configuration at Run/Debug Configurations.</summary></entry><entry><title type="html">How to add a Server Runtime Library to a Java EE project using IntelliJ IDEA</title><link href="http://localhost:4000/java/how-to-add-a-server-runtime-library-to-a-java-ee-project-using-intellij-idea/" rel="alternate" type="text/html" title="How to add a Server Runtime Library to a Java EE project using IntelliJ IDEA" /><published>2014-11-13T12:23:49-03:00</published><updated>2014-11-13T12:23:49-03:00</updated><id>http://localhost:4000/java/how-to-add-a-server-runtime-library-to-a-java-ee-project-using-intellij-idea</id><content type="html" xml:base="http://localhost:4000/java/how-to-add-a-server-runtime-library-to-a-java-ee-project-using-intellij-idea/">After I have some difficult to add server libraries to the project, because in IntelliJ is a lit bit different from Eclipse, I’ve decided to post the solution:

After the project has been opened you will need go in **File** -&gt; **Project Structure**.

&lt;figure style=&quot;width: 300px&quot; class=&quot;align-center&quot;&gt;
    &lt;a href=&quot;/assets/images/intelliJ/pic_01.png&quot;&gt;&lt;img src=&quot;/assets/images/intelliJ/pic_01.png&quot;&gt;&lt;/a&gt;
&lt;/figure&gt;

After that you’ll see the structure of project. In this way, where you need to add a dependency. In the left side column you’ll choose **modules** in Project Settings, choose **Dependencies tab(1),** to click on **+** in the bottom of window and select **Library… (2)**, like below.

&lt;figure&gt;
    &lt;a href=&quot;/assets/images/intelliJ/pic_02.png&quot;&gt;&lt;img src=&quot;/assets/images/intelliJ/pic_02.png&quot;&gt;&lt;/a&gt;
&lt;/figure&gt;

When you click on **Library…** it will open a window asking you to select the server libraries.
IntelliJ will show only the servers that **you have added** before.

&lt;figure&gt;
    &lt;a href=&quot;/assets/images/intelliJ/pic_03.png&quot;&gt;&lt;img src=&quot;/assets/images/intelliJ/pic_03.png&quot;&gt;&lt;/a&gt;
&lt;/figure&gt;

&lt;figure style=&quot;width: 300px&quot; class=&quot;align-right&quot;&gt;
    &lt;a href=&quot;/assets/images/intelliJ/pic_04.png&quot;&gt;&lt;img src=&quot;/assets/images/intelliJ/pic_04.png&quot;&gt;&lt;/a&gt;
&lt;/figure&gt;

After all of this steps your project will rebuild the project and problems related with compile-time should be solved.

Finally your project will be this way.

Any problems that you have, ask me.</content><author><name>felipealvesgnu</name></author><summary type="html">After I have some difficult to add server libraries to the project, because in IntelliJ is a lit bit different from Eclipse, I’ve decided to post the solution:</summary></entry><entry><title type="html">Install oracle client 11 (64 bits) on ubuntu(64 bits) 12</title><link href="http://localhost:4000/java/linux/install-oracleclient-11-64-bits-no-ubuntu64-bits-12-04/" rel="alternate" type="text/html" title="Install oracle client 11 (64 bits) on ubuntu(64 bits) 12" /><published>2012-06-29T18:41:03-04:00</published><updated>2012-06-29T18:41:03-04:00</updated><id>http://localhost:4000/java/linux/install-oracleclient-11-64-bits-no-ubuntu64-bits-12-04</id><content type="html" xml:base="http://localhost:4000/java/linux/install-oracleclient-11-64-bits-no-ubuntu64-bits-12-04/">I have recently faced some difficulties in installing the oracle client in ubuntu and have JBoss 'see' the client installation, since it is approved for RedHat distributions, so I would like to share with you the settings that I, with the help of some friends of the work, I was able to make the connection with the UNICAMP - University of Campinas (where the project is located).

  
### Installing the JDK and setting JAVA_HOME

First follow the step-by-step [here](https://askubuntu.com/a/89080/68882).
After that set the environment variables in `/etc/profile` file adding the follow lines:

``` shell
$ export JAVA_HOME=/usr/lib/jvm/java-6-oracle
$ export PATH=$PATH:$JAVA_HOME/bin
```
#### PS.: Now restart the PC


## Getting started OracleClient 64 on ubuntu


### Step 1: Downloading the stuff

Go ahead and download Oracle Client 11g X64 (I'm using R1 cause I had it before, but R2 might work as well)

**Warning:** From now on, you should run all command as a root user. 
{: .notice--warning}

### Step 2: Updates

```shell
$ apt-get install alien build-essential gawk ksh lesstif2 
  libaio1 libaio-dev libtool expat unixodbc sysstat libxml2-dev 
  libxml2-utils zlib1g zlib1g-dev libjpeg8-dev libpng12-dev 
  libfreetype6-dev autoconf
```

### Step 3: Dash to Bash (as Dash is the default sh and we need Bash):
```shell
$ cd /bin
$ ln -sf bash /bin/sh
```

### Step 4: Creating user/group
```shell
 $ adduser oracle
```
Ubuntu will create an 'oracle' group aswell, just type 'oracle' as password and leave everything blank then ur done.

### Step 5: A Few Symlinks
```shell
$ cd /bin
$ ln -s /usr/bin/awk /bin/awk
$ ln -s /usr/bin/rpm /bin/rpm
$ ln -s /usr/bin/basename /bin/basename
$ mkdir /usr/lib64
$ ln -s /usr/lib/x86_64-linux-gnu/libpthread_nonshared.a /usr/lib64/libpthread_nonshared.a
$ ln -s /usr/lib/x86_64-linux-gnu/libc_nonshared.a /usr/lib64/libc_nonshared.a
```

### Step 6: Create Oracle Client's directory
```shell
$ mkdir -p /u01/app/
$ chown -R oracle:oracle /u01
$ xhost +
$ apt-get install synaptic
```

Open **synaptic**, to search **libstdc++ 5 **and install it, in some versions of Ubuntu is shipping a higher version.

### Step 7: Get ready to runInstaller

When you start the installation you'll choose the “Administrator option”, because it's a bit complete, even I need a client oracle oci connection. After that the oracle client installation will be displayed many errors, so you'll need to run the sh scripts.

```shell
$ su oracle
$ ./runInstaller
```

### Step 8: Update the file name databases

After to run the installation and its corrections run:
```shell
$ updatedb
```

### Step 9: Setting environment variables

**Info:** the oracle_home is the directory where the installation was performed, check in your environment...
{: .notice--info}

Add the environment variables in the `/etc/profile` file by adding the 2 lines below at the end of the file.
```bash
$ export ORACLE_HOME=/u01/app/oracle/product/11.2.0/client_1
$ export PATH=$PATH:$ORACLE_HOME/bin
``` 
  
### Step 10: Publish libs to Linux

You should register the oracle 11g lib path in `/etc/ld.so.conf.d`:
Create a file called `oracle.conf`,  inside `/etc/ld.so.conf.d` directory, with this content on the first line:
```bash
/u01/app/oracle/product/11.2.0/client_1/lib
```

Run the touch command:
```bash
$ touch /etc/ld.so.conf.d/oracle.conf
````

Finally
```bash
$ ldconfig -v   #Update the links/cache 
$ ldconfig -p | grep oracle 
``` 
the terminal may return an alert saying that it could not find the link for a given lib, normal this 'error' appears)


That's all :rocket: :rocket: :rocket:</content><author><name>felipealvesgnu</name></author><category term="JBoss" /><category term="oracleclient" /><category term="Ubuntu" /><summary type="html">I have recently faced some difficulties in installing the oracle client in ubuntu and have JBoss ‘see’ the client installation, since it is approved for RedHat distributions, so I would like to share with you the settings that I, with the help of some friends of the work, I was able to make the connection with the UNICAMP - University of Campinas (where the project is located).</summary></entry><entry><title type="html">Serialização e Desserialização de Objetos em Java</title><link href="http://localhost:4000/java/serializacao-e-desserializacao-de-objetos/" rel="alternate" type="text/html" title="Serialização e Desserialização de Objetos em Java" /><published>2010-12-19T00:00:00-03:00</published><updated>2010-12-19T00:00:00-03:00</updated><id>http://localhost:4000/java/serializacao-e-desserializacao-de-objetos</id><content type="html" xml:base="http://localhost:4000/java/serializacao-e-desserializacao-de-objetos/">**Serialização**

Suponhamos que você tivesse um programa, um jogo com uma aventura fictícia que precisasse de mais de uma sessão para ser concluído. Conforme o jogo progride, os personagens ficammais fortes, fracos, inteligentes, etc. E coletam e usam (e perdem armas). Você não quer iniciar do zero sempre que iniciar o jogo ? Portanto precisa de uma maneira de salvar o estado dos personagens e uma maneira de restaurá-lo quando voltar ao jogo.

1. Opção
  * Grave os objetos serializados dos personagens em um arquivo.

2. Opção 	
  * Grave um arquivo de texto simples.


**Gravando um objeto serializado em um arquivo**

Aqui estão as etapas para serializarmos (salvarmos) um objeto.

```java
//1 - Crie um objeto FileOutputStream
 FileOutputStream fileStream = new FileOutputStream(&quot;MyGame.ser&quot;);
 //2 - Crie um ObjectOutputStream
 ObjectOutputStream os = new ObjectOutputStream(fileStream);
 //3 - Grave os objetos
 os.writeObject(personagemUm); //Serializa os objetos referenciados por
 os.writeObject(personagemDois);//personagemUm,personagemDois,personagemTres
 os.writeObject(personagemTres); //e grava no arquivo myGame.ser
 //4 - Feche ObjectOutputStream
 os.close;
```

**Transferência de dados do streams de um local para outro**

A API de E/S Java tem streams de **conexão** que representam conexões com destinos e origens como arquivos ou
soquetes de rede, stream de **cadeia** que só funcionam quando encadeados a outros streams.

Geralmente, são necessários dois streams para que algo útil possa ser feito - um para representar a conexão
e outro para chamar métodos. Pois os streams de conexão costuma estar em um nível muito baixo.
FileOutputStream (um stream de conexão), por exemplo, tem métodos para a gravação de bytes. Mas não queremos
gravar bytes! Queremos gravar objetos, portanto, precisamos de um stream de _cadeia_ de nível mais alto. Veja descrição na figura 1.

&lt;figure&gt;
    &lt;a href=&quot;/assets/images/serializacao/serialization.jpg&quot;&gt;&lt;img src=&quot;/assets/images/serializacao/serialization.jpg&quot;&gt;&lt;/a&gt;
    &lt;figcaption&gt;Figura 1&lt;/figcaption&gt;
&lt;/figure&gt;


**Implemente _Serializable_**

Serializable é considerada como uma interface _marcadora_ ou de _tag_, porque não tem nenhum um método a implementar. Sua única finalidade é anunciar que a classe que está implementando pode ser serializada. Ou seja os objetos desse tipo poderão ser salvos através do mecanismo de serialização. (Se sua superclasse &quot;FOR-UM&quot; tipo serializable, você também  será). Segue exemplo abaixo.

```java
import java.io.FileOutputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

public class Box implements Serializable {

 private int largura;
 private int altura;

 public static void main(String[] args) {
  Box myBox = new Box();
  myBox.setLargura(50);
  myBox.setAltura(20);

   try { //operação de E/S pode lançar excessões.
     FileOutputStream fs = new FileOutputStream(&quot;foo.ser&quot;);//caso não encontre cria novo arquivo chamado foo.ser
     ObjectOutputStream os = new ObjectOutputStream(fs); //fs encadeado ao stream de conexão
     os.writeObject(myBox);
     os.close();
   }catch (Exception e) {
     e.printStackTrace();
   }
 }

 public void setLargura(int largura) {
   this.largura = largura;
 }

 public void setAltura(int altura) {
   this.altura = altura;
 }
}
```

**Desserialização: restaurando um objeto**

O objetivo da serialização de um objeto é podermos restaurá-lo a seu estado original em algum momento posterior, em uma execução diferente da JVM (que pode até ser a mesma que estava sendo executada no momento em que o objeto foi serializado). A desserialização é muito parecida com a serialização ao contrário.

Aqui estão as etapas para desserializarmos (abrir) um objeto.

```java
//1 - Crie um objeto FileInputStream
 FileInputStream fileStream = new FileInputStream(&quot;MyGame.ser&quot;);
 //2 - Crie um ObjectInputStream
 ObjectInputStream os = new ObjectInputStream(fileStream);
 //3 - Leia os objetos
 Object um = os.readObject();
 Object dois = os.readObject();
 Object tres = os.readObject();
 //4 - Converta os objetos
 GamePersonagem duende   = (GamePersonagem) um;
 GamePersonagem duende_2 = (GamePersonagem) dois;
 GamePersonagem magico   = (GamePersonagem) tres;

 //5 - Feche ObjectInputStream
 os.close();
````

**O que acontece durante a desserialização?**

Quando um objeto é desserializado, a JVM tenta reconstituí-lo criando um novo objeto no acervo que tenha o mesmo
estado que objeto serializado tinha na hora em que foi serializado. Exceto pelas variáveis transientes,
que são reconstituídas com nulo(para referências de objeto) ou com valores primitivos padrão.

Lembrando sempre que se desserialização for em um local diferente (outro sistema por exemplo)  deverá existir a cópia da classe de origem (que foi utilizada para fazer a serialização anteriormente)  para que seja feita a desserialização desse objeto que está sendo manipulado, conforme ilustra abaixo a figura 2.

&lt;figure&gt;
    &lt;a href=&quot;/assets/images/serializacao/desserialization.jpg&quot;&gt;&lt;img src=&quot;/assets/images/serializacao/desserialization.jpg&quot;&gt;&lt;/a&gt;
    &lt;figcaption&gt;Figura 2&lt;/figcaption&gt;
&lt;/figure&gt;

PONTOS CHAVES

- Uma variável de instância com a palavra-chave ```transient``` se quiser que a serialização a ignore.

- Durante a desserialização, a classe de todos os objetos da ramificação deve estar disponível na JVM.

Referências Bibliográficas

 *SIERRA, Kathy; BATES, Bert - Use a Cabeça Java - Editora Alta Books, Rio de Janeiro, 2010.*</content><author><name>felipealvesgnu</name></author><summary type="html">Serialização</summary></entry></feed>